---
title: 'Chatbot : Coder Proprement Un Webhook Avec NestJs'
description: Mettons en place une architecture propre pour faciliter le d√©veloppement d'un chatbot et sa maintenabilit√©.
date: '2021-07-31'
update: '2021-07-31'
categories: ['backend', 'design-pattern', 'nest-js']
slug: clean-architecture-chatbot-webhook
---

√Ä [Hello Doe](https://hellodoe.co/), on a pour mission d'aider les √©tudiants √† trouver des jobs pendant leurs √©tudes. On d√©marche les entreprises, on obtient des missions qu'on poste sur les [r√©seaux sociaux](https://www.instagram.com/hellodoe_/) et les doers (les √©tudiants) postulent en un clic depuis [notre chatbot](https://www.messenger.com/t/282545635647987) sur Facebook Messenger.

Le chatbot nous permet de proposer un syst√®me sans friction aux doers qui n'ont pas besoin de t√©l√©charger d'application suppl√©mentatire pour acc√©der aux missions et √† leur candidature.

L'ajout de nouvelles fonctionnalit√©s et la croissance de l'√©quipe tech a n√©cessit√© de revoir l'impl√©mentation de notre webhook avec pour objectifs :

- Garantir la lisibilit√© du code.
- Permettre la maintenabilit√© et la testabilit√©.
- Respecter l'Open/Close Principle.
- √âlaborer une architecture qui parle d'elle m√™me pour faciliter sa compr√©hension.

Je vais d√©crire notre solution en me focalisant sur l'architecture du code uniquement, sans d√©crire le fonctionnement d'un chatbot et la mani√®re dont s'interface un webhook avec une plateforme pour cr√©er un chatbot.

Ceci √©tant dit, on peut commencer sans plus attendre par

## Un Aller Simple Droit Dans Le Mur üß±üèÉ

La fa√ßon la plus simple de coder le webhook est d'√©crire tous les handlers dans un seul et m√™me fichier. De cette mani√®re ils sont centralis√©s et n'importe quel dev sait o√π aller quand il s'agit d'y toucher.

√áa pourrait ressembler √† √ßa :

```typescript
@Injectable()
export class Handler {
  constructor(
    @InjectUserRepository private readonly userRepo: UserRepositiry,
    @InjectMissionRepository private readonly missionRepo: MissionRepository,
  ) {}

  // La m√©thode re√ßoit la requ√™te de la plateforme
  // de chatbot et la transforme en une action
  // qu'elle traite.
  public async handle(request: RequestBody): Promise<void> {
    const action = this.createAction(request);

    await this.handleAction(action);
  }

  // handleAction s'occupe de traiter l'action
  public async handleAction(action: Action): Promise<void> {
    // Selon l'action d√©cl√©nch√©e par le doer on branche
    // sur telle ou telle m√©thode.
    // Ici on va s'occuper de cr√©er un nouveau doer.
    if (action.getName() === ActionNames.CREATE_DOER) {
      await this.createDoer(action);
      // Et l√† on va r√©cup√©rer une mission en base pour
      // la retourner au doer.
    } else if (action.getName() === ActionNames.GET_MISSION) {
      await this.getMission(action);
    }
  }

  // Cr√©e un nouveau doer en base de donn√©es.
  public async createDoer(action: Action): Promise<void> {
    const username = action.getParameter('username');

    if (!username) {
      throw new Error(`Missing parameter username`);
    }

    await this.userRepo.create(username);
  }

  // Cherche une mission et la retourne au doer.
  public async getMission(action: Action): Promise<void> {
    const missionId = action.getParameter('missionId');

    if (!missionId) {
      throw new Error(`Missing parameter missionId`);
    }

    const mission = await this.missionRepo.findById(missionId);

    if (mission) {
      action.addMessage(`Voil√† ta mission servie sur un plateau üçΩÔ∏è`);
      action.addMessage(`${mission.company} recrute pour sa mission de ${mission.category}`);
    } else {
      action.addMessage(`Nous n'avons pas trouv√© la mission que tu cherches`);
      action.addMessage(`On te pr√©sente les missions du moment ?`, `Oui`, `Non`);
    }
  }

  // Cr√©e l'action √† partir de la requ√™te du chatbot.
  private createAction(request: RequestBody): Action {
    // Extraction des param√®tres depuis la requ√™te et
    // cr√©ation de l'action.
    // ...

    return action;
  }
}
```

J'ai volontairement charg√© l'exemple pour me rapprocher d'un webhook r√©aliste.

Ici notre webhook g√®re 2 actions :

- `ActionNames.CREATE_DOER` : le chatbot demande au webhook de cr√©er un nouvel utilisateur en base de donn√©es.
- `ActionNames.GET_MISSION` : le chatbot demande √† r√©cup√©rer une mission en base pour l'afficher sur Facebook Messenger.

Des sous-fonctions `createDoer` et `getMission` ont √©t√© cr√©√©es pour soulager la fonction `handleAction` qui s'occupe de dispatcher l'action.

Ce qu'on sent d√©j√†, c'est que m√™me si le code est centralis√© on va vite ramasser nos dents ü¶∑ Pour le moment on n'a que deux actions g√©r√©es mais on va vite commencer √† avoir de la mis√®re √† lire le fichier. On va se retrouver avec une classe qui g√®re toutes les actions de notre chatbot dont les effets et les d√©pendances sont diff√©rents.

Par exemple, le `UserRepository` est pertinent quand on veut cr√©er un nouveau doer avec l'action `ActionNames.CREATE_DOER`, mais ne l'est plus quand on veut r√©cup√©rer une mission. Notre classe `Handler` va rapidement perdre en coh√©sion.

Et puis comment √ßa se teste ? De la m√™me mani√®re, √ßa va donner un √©norme fichier fourre-tout. Sans parler des r√©gressions √©ventuelles dues au fait qu'un(e) dev touchera √† du code partag√© par plusieurs fonctionnalit√©s.

L'enfer.

<Image src="/images/articles/sponge-bob-smelly.gif" width={1200} height={630} className="mb-9" />

## La Consultation Chez Le Dentiste ü©∫üçì

Les probl√®mes mentionn√©s plus haut viennent du fait que tous les handlers sont √©crits dans un seul et m√™me fichier.

En mettant √† plat les d√©pendances, on obtient le graphe suivant :

<Image src="/images/articles/webhook-rotten-1.png" width={1200} height={630} className="mb-9" />

Carie en cours de formation

Alors que si on place chaque handler dans son propre fichier, √ßa r√®gle pas mal de probl√®mes. √áa donnerait le sch√©ma suivant :

<Image src="/images/articles/webhook-clean.png" width={1200} height={630} className="mb-9" />

Dentition saine

Un telle architecture permettrait de :

- G√©rer une nouvelle action facilement : il suffit de cr√©er un nouveau handler dans un fichier d√©di√© et c'est pli√©.
- Tester : de nouveau on a un fichier de test par handler et seules les d√©pendances du handler en question sont √† mocker.
- Am√©liorer la lisibilit√© : on se retrouve avec plusieurs fichiers de 100 lignes plut√¥t qu'un fichier de 1000.

Avec √ßa le webhook sera ouvert √† l'extension et ferm√© √† la modification. Et √ßa, √ßa me botte.

## Un Bon Coup De Brosse √Ä Dents ü™•‚ú®

Passons √† l'impl√©mentation en commen√ßant par d√©finir l'interface `ActionHandler` que vont impl√©menter les handlers :

```typescript
export interface ActionHandler {
  // Indique si le ActionHandler prend
  // en charge l'action.
  canHandle: (action: Action) => boolean;

  // Prend en charge l'action.
  // La m√©thode prend une action d√©j√† cr√©√©e au
  // lieu de la cr√©er lui m√™me.
  handle: (action: Action) => Promise<void>;
}
```

L'id√©e est que quand on re√ßoit une action depuis le chatbot, on parcourt chacun des `ActionHandler` jusqu'√† en trouver un qui prenne en charge l'action.

Pla√ßons nos 2 `ActionHandler` dans leur propre fichier :

```typescript
@Injectable()
export class CreateDoerHandler {
  constructor(@InjectUserRepository private readonly userRepo: UserRepositiry) {}

  // L'action est prise en charge si son nom est
  // ActionNames.CREATE_DOER.
  public canHandle(action: Action): boolean {
    return action.getName() === ActionNames.CREATE_DOER;
  }

  // Prend en charge l'action de cr√©ation d'un
  // nouveau doer.
  public async handler(action: Action): Promise<void> {
    const username = action.getParameter('username');

    if (!username) {
      throw new Error(`Missing parameter username`);
    }

    await this.userRepo.create(username);
  }
}
```

```typescript
@Injectable()
export class GetMissionHandler {
  constructor(@InjectMissionRepository private readonly missionRepo: MissionRepository) {}

  // Ici l'action est prise en charge si son nom est
  // ActionNames.GET_MISSION.
  public canHandle(action: Action): boolean {
    return action.getName() === ActionNames.GET_MISSION;
  }

  // Cherche une mission en base et la retourne au doer.
  public async handle(action: Action): Promise<void> {
    const missionId = action.getParameter('missionId');

    if (!missionId) {
      throw new Error(`Missing parameter missionId`);
    }

    const mission = await this.missionRepo.findById(missionId);

    if (mission) {
      action.addMessage(`Voil√† ta mission servie sur un plateau üçΩÔ∏è`);
      action.addMessage(`${mission.company} recrute pour sa mission de ${mission.category}`);
    } else {
      action.addMessage(`Nous n'avons pas trouv√© la mission que tu cherches`);
      action.addMessage(`On te pr√©sente les missions du moment ?`, `Oui`, `Non`);
    }
  }
}
```

C'est d√©j√† bien plus lisible. C√¥t√© testabilit√© c'est bien aussi puisque chaque `ActionHandler` n'a comme services inject√©s que ceux dont il a r√©ellement besoin. L'id√©e √©tant la m√™me pour les fichiers de test, je m'attarde pas sur leur impl√©mentation.

Ensuite, on va avoir besoin du `DispatchService`. Son r√¥le est de construire l'action depuis la requ√™te du chatbot et de s√©lectionner le bon handler pour la g√©rer. Son code est le suivant :

```typescript
@Injectable()
export class DispatchService {
  // Liste des handlers disponibles.
  private handlers: ActionHandler[] = [];

  // On injecte les handlers et on les stockes dans
  // la liste de handlers.
  constructor(
    @InjectCreateDoerHandler createDoerHandler: CreateDoerHandler,
    @InjectGetMissionHandler getMissionHandler: GetMissionHandler,
  ) {
    this.handlers = [createDoerHandler, getMissionHandler];
  }

  // S√©lectionne le bon handler capable de traiter
  // l'action.
  public async dispatchAction(request: RequestBody): Promise<void> {
    // Cr√©ation de l'action.
    const action = this.createAction(request);

    // On manipule un ActionHandler pour s'abstraire
    // des impl√©mentations concr√®tes des handlers.
    const handler: ActionHandler = this.getHandler(action);

    // On retrouve notre m√©thode handle.
    await handler.handle(action);
  }

  public getHandler(action: Action): ActionHandler {
    for (const handler of this.handlers) {
      // On retrouve notre m√©thode canHandle.
      if (handler.canHandle(action)) {
        return handler;
      }
    }

    // Si on n'a pas trouv√© de handler, c'est que le
    // chatbot d√©clenche une action qui n'est pas
    // g√©r√©e par l'api. On l√®ve une erreur car on ne
    // peut pas aller plus loin.
    throw new Error(`No handler found to handle action ${action.getName()}`);
  }

  // On retrouve notre logique qui cr√©e une action
  // √† partir d'une requ√™te web.
  private createAction(request: RequestBody): Action {
    // Extraction des param√®tres de la requ√™te et
    // cr√©ation de l'action.
    // ...

    return action;
  }
}
```

Le `DispatchService` a simplement √† √™tre branch√© √† l'entr√©e de notre api, on passe la requ√™te √† la m√©thode `dispatchAction` et le tour est jou√© üëå L'avantage c'est qu'une fois cette logique mise en place, on n'a plus besoin d'y toucher. On vient de s√©parer ce qui change (la gestion des actions par les `ActionHandler`) de ce qui ne change pas (la s√©lection du bon handler par le `DispatchService`), et √ßa c'est gourmand üç∞

## √âpilogue

On vient de s'offrir une belle dentition avec cette nouvelle architecture en plus d'atteindre les objectifs qu'on s'√©tait fix√©, √† savoir :

- Garantir la lisibilit√© du code
- Permettre la maintenabilit√© et la testabilit√©
- Respecter l'Open/Close Principle
- √âlaborer une architecture qui parle d'elle m√™me pour faciliter sa compr√©hension

Je vois 2 points principaux √† am√©liorer :

Le premier est le chargement fastidieux des handlers : pour chaque nouveaux handlers, il faut penser √† l'ajouter dans le module NestJs ET dans le `DispatchService`. On verra dans un prochain article comment s'affranchir de cette contrainte.

Le deuxi√®me serait de d√©placer la construction de l'action dans un service d√©di√© plut√¥t que de le faire dans le `DispatchService`. Ce nouveau service recevrait la requ√™te du chatbot puis construirait une action qu'il passerait au `DispatchService`. De cette mani√®re, le `DispatchService` s'occuperait seulement de s√©lectionner le bon handler. La logique de cr√©ation de l'action √©tant d√©pendante de la structure de la requ√™te http et donc de la plateforme de chatbot utilis√©e, on poserait la seconde brique d'un syst√®me qui prot√©gerait notre logique m√©tier d'une interface sur laquelle on n'a pas la main. La premi√®re √©tant la cr√©ation de l'interface `Action` qu'on a utilis√©e tout au long de l'article.
