---
title: Automatiser Ses Injections Avec Le DiscoveryModule De NestJs
description: Voyons ensemble comment faciliter l'ajout de nouveaux service en automatisant nos injections.
date: '2021-10-19'
updated: '2021-10-19'
categories: ['nest-js', 'backend']
slug: dependency-injection-with-nest-js-discovery-module
---

Dans l'article pr√©c√©dent, une architecture √† √©t√© propos√©e pour faciliter le d√©veloppement et le maintient du webhook de notre chatbot (cf [Chatbot : Coder Proprement Un Webhook Avec NestJs](https://basile-mousketon.com/chatbot-coder-proprement-un-webhook-avec-nestjs/)).

En partant de cette base, on va voir comment faciliter l'ajout de nouveaux handlers en automatisant nos injections.

Pour le moment, pour charger les handlers dans le `DispatchService`, ce que nous faisons est d'injecter les handlers un √† un et de les stocker dans la liste de handlers :

```typescript
@Injectable()
export class DispatchService {
  // Liste des handlers disponibles.
  private handlers: ActionHandler[] = [];

  // On injecte les handlers et on les stocke dans
  // la liste de handlers.
  constructor(
    @InjectCreateDoerHandler createDoerHandler: CreateDoerHandler,
    @InjectGetMissionHandler getMissionHandler: GetMissionHandler,
  ) {
    this.handlers = [createDoerHandler, getMissionHandler];
  }

  // ...
}
```

√áa se fait, mais est-ce qu'il n'y aurait pas un moyen qui permettrait de le faire automatiquement pour ne pas [se casser la n√©nette](https://www.cnews.fr/culture/2013-02-13/pourquoi-dit-se-casser-la-nenette-381806) ? L'id√©e c'est de ne plus avoir √† toucher la logique du `DispatchService` seulement pour ajouter un handler dans la liste. Par exemple, est-ce qu'il y'a moyen de charger les handlers automatiquement une fois qu'ils ont √©t√© ajout√©s dans le module ?

<Image src="/images/articles/anxious.gif" width={1200} height={630} className="mb-9" />

_A√Øe mais quel suspens, j'esp√®re vraiment que l'auteur de l'article a une astuce pour √ßa sinon √ßa n'a aucun int√©r√™t_ üò∞

Tkt frelot(te) √† la compote, j'ai tout pr√©vu.

Commen√ßons par

## La d√©couverte du `DiscoveryModule` de NestJs üõ∞üîç

Le `DiscoveryModule` fait partie du core package de NestJs. C'est le module qui permet au framework de trouver les bons services √† injecter en se basant sur leurs metadata.

Par exemple, NestJs sait qu'une classe est injectable gr√¢ce √† l'annotation `@Injectable()`. En allant voir dans le code source, on s'aper√ßoit que ce d√©corateur ne fait qu'ajouter des metadata √† la classe annot√©e :

```typescript
// √áa se code √† une main.
export function Injectable(options?: InjectableOptions): ClassDecorator {
  return (target: object) => {
    // NestJs se base sur la Metadata Reflection API
    // pour ajouter des metadonn√©es √† la classe
    // qu'on veut rendre injectable.
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}
```

Je rentre pas dans les d√©tails de la Metadata Reflection API parce que √ßa ferait un article bien trop gros.

Partant de l√†, on peut utiliser la m√™me m√©canique pour marquer les classes qui sont des handlers. Il suffit de leurs ajouter une metadata maison puis de les r√©cup√©rer gr√¢ce au `DiscoveryService` et sa m√©thode `getProviders()`.

### Apart√© sur la m√©thode `getProviders()`

Comme son nom l'indique, la m√©thode r√©cup√®re l'ensemble des providers inject√©s dans l'application. Et elle fait √ßa sans distinction de module. ‚úäüèª‚úäüèº‚úäüèΩ‚úäüèæ‚úäüèø

Par exemple, si on consid√®re les modules suivants :

```typescript
@Module({
  providers: [ProviderA],
})
export class ModuleA {}
```

```typescript
@Module({
  providers: [ProviderB],
})
export class ModuleB {}
```

Et qu'on les injecte dans notre `AppModule` :

```typescript
@Module({
  imports: [ModuleA, ModuleB],
})
export class AppModule {}
```

M√™me si `ProviderA` et `ProviderB` n'ont pas √©t√© export√©s depuis leur module respectif, on les retrouvera quand m√™me dans la liste de handlers retourn√©e par la m√©thode `getProviders()`.

Pour √™tre pr√©cis, la m√©thode retourne une liste de `InstanceWrapper` qui poss√®dent 2 propri√©t√©s int√©ressantes :

- `metatype` : contient les m√©tadonn√©es de la classe provid√©e. On va utiliser la Metadata Reflection API pour aller chercher la m√©tadonn√©e qui nous int√©resse.
- `instance` : contient une instance de la classe provid√©e. Dans notre cas, √ßa sera une instance de handler si le provider poss√®de la bonne m√©tadonn√©e.

---

Ceci √©tant dit, on peut faire une premi√®re √©bauche pour trouver les providers qui sont des handlers en utilisant le `DiscoveryService` :

```typescript
@Injectable()
export class DispatchService {
  // Liste des handlers disponibles.
  private handlers: ActionHandler[] = [];

  // Le DiscoveryService de NestJs nous permet
  // de trouver des services en se basant sur leurs
  // metadata.
  // Plus besoin d'injecter les handlers √† la main.
  constructor(private readonly discoverySvc: DiscoveryService) {}

  // On cherche les handlers une fois que le
  // ChatbotModule a √©t√© initialis√©.
  onModuleInit(): void {
    this.discoverHandlers();
  }

  // Cherche les handlers gr√¢ce √† leur metadata.
  private discoverHandlers(): void {
    this.handlers = this.discoverySvc
      // On r√©cup√®re la liste de l'ensemble des
      // providers inject√©s dans l'application.
      .getProviders()
      // On ne garde que les providers qui
      // poss√®dent la bonne metadata.
      .filter(
        wrapper =>
          !!wrapper.metatype && !!Reflect.getMetadata(NOTRE_METADATA_MAISON, wrapper.metatype),
      )
      // Enfin, on r√©cup√®re l'instance du provider.
      .map((wrapper: InstanceWrapper<ActionHandler>) => wrapper.instance);
  }

  // ...
}
```

## L'injection sans pression üíâüçª

Maintenant qu'on a notre strat√©gie, on peut passer √† l'impl√©mentation.

En reprenant la logique plus haut, on va commencer par cr√©er notre propre d√©corateur pour injecter notre metadata maison :

```typescript
import { CustomDecorator, SetMetadata } from '@nestjs/common';

// Notre metadata maison.
export const ACTION_HANDLER_METADATA_KEY = 'CHATBOT_HANDLER';

// Et notre d√©corateur maison qui se contente
// d'associer un simple bool√©en √† notre metadata.
export const ActionHandlerDecorator = (): CustomDecorator =>
  SetMetadata(ACTION_HANDLER_METADATA_KEY, true);
```

On peut ensuite l'appliquer √† chacun de nos handlers.

En reprenant ceux de [l'article pr√©c√©dent](https://basile-mousketon.com/chatbot-coder-proprement-un-webhook-avec-nestjs/), √ßa nous donne :

```typescript
@Injectable()
@ActionHandlerDecorator()
export class CreateDoerHandler {
  // ...
}
```

```typescript
@Injectable()
@ActionHandlerDecorator()
export class GetMissionHandler {
  // ...
}
```

Il ne nous reste plus qu'√† adapter le `DispatchService` pour filtrer les providers selon la bonne metadata :

```typescript
@Injectable()
export class DispatchService {
  // ...

  // Cherche les handlers gr√¢ce √† leur metadata.
  private discoverHandlers(): void {
    this.handlers = this.discoverySvc
      .getProviders()
      // On ne garde que les providers qui
      // poss√®dent la bonne metadata.
      .filter(
        wrapper =>
          !!wrapper.metatype &&
          !!Reflect.getMetadata(ACTION_HANDLER_METADATA_KEY, wrapper.metatype),
      )
      .map((wrapper: InstanceWrapper<ActionHandler>) => wrapper.instance);
  }
}
```

## √âpilogue

Pour r√©sumer, au lancement du programme, le `DispatchService` va parcourir l'ensemble des providers r√©pertori√©s dans l'application pour ne garder que ceux qui ont notre metadata maison `ACTION_HANDLER_METADATA_KEY` et les stocker dans sa liste de handlers.

Cr√©er un nouveau handler est maintenant plus simple que jamais : il suffit de

1. Cr√©er une nouvelle classe injectable.
2. Annoter la classe avec notre d√©corateur `ActionHandlerDecorator`.
3. Ajouter la classe dans les providers de notre application.

Le `DispatchService` se charge du reste, sans qu'on ait √† le modifier.
